<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>JQuery 筛选器</title>
    <link rel="stylesheet" type="text/css" href="../../css/public.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/Classroom.css"/>
    <script src="../../js/jquery-2.1.1.min.js"></script>
</head>
<body>
<div id="content">
    <div id="c_left">
        <section id="Grooveshark">
            <h1>
				call()和apply()方法
				<br />
				http://uule.iteye.com/blog/1158829
				<br />
				http://www.jb51.net/article/89501.htm
            </h1>
            <section>
                <h5>
					call() 语法：call([thisObj[,arg1],[arg2],[argN]...) 
                </h5>
                <pre>
定义：调用一个对象的一个方法，以另一个对象替换当前对象。 
说明： 
call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象
  上下文从初始的上下文改变为由 thisObj 指定的新对象。 
如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj

事例1：
function add(a,b){  
    console.log(a+b); }  

function sub(c,d){  
    console.log(c-d); }  
  
add.call(sub,3,2);   //5
add.call(null,3,2);  //5
//匹配的函数方法、与cell方法里第2个传参起、作为匹配方法的传参 

事例2：
function Animal(name){      
    this.name = name;      
    this.showName = function(){      
        console.log(this.name);  }}      
    
function Cat(name){    
    Animal.call(this, name);//即 Animal(name)
}      
    
var cat = new Cat("Black Cat");     
cat.showName();//Black Cat

事例3：
function Animal2(){    
    this.name = "Animal";    
    this.showName = function(){    
        console.log(this.name);}}    
  
function Cat2(){    
    this.name = "Cat";   	}    
   
var a = new Animal2();    
var c = new Cat2();    
    
//  console.log(c.name);//c已执行
a.showName.call(c,",");  //Cat 函数子域后执行的覆盖前面的this
                </pre>
            </section>
            <section>
                <h5>
					apply() 语法：apply([thisObj],[argArray]) 
                </h5>
                <pre>
语法：Function.apply([thisObj],[argArray]) 
定义：应用某一对象的一个方法，用另一个对象替换当前对象。
  obj：这个对象将代替Function类里this对象
  args：这个是数组或类数组，apply方法把这个集合中的元素作为参数传递
      给被调用的函数。


说明： 
如果 argArray 不是一个有效的数组或者不是 arguments 对象，
  那么将导致一个 TypeError。 
如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被
  用作 thisObj， 并且无法被传递任何参数。
                </pre>
            </section>
            <span></span>
        </section>
    </div>
    <div id="c_right">
        <section>
            <h2>
                练习
            </h2>
            <section>
                <h5>
                    111111111
                </h5>
                <p>
                    JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。
                    为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格，因为JavaScript兼容于ECMA标准，因此也称为ECMAScript。
                    在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。
                </p>
            </section>
        </section>
        <span></span>
    </div>
</div>

<script>
//	.call()
	function add(a,b){  
//	    console.log(a+b);  
	}  
	
	function sub(c,d){  
	    console.log(c-d);  
	}  
	  
	add.call(sub,3,2);   //5
	add.call(null,3,2);  //5
	//匹配的函数方法、与cell方法里第2个传参起、作为匹配方法的传参 

//---------------------------------------------------------------

	function Animal(name){      
	    this.name = name;      
	    this.showName = function(){      
//	        console.log(this.name);      
	    }      
	}      
	    
	function Cat(name){    
	    Animal.call(this, name);//即 Animal(name)
	}      
	    
	var cat = new Cat("Black Cat");     
	cat.showName();//Black Cat
	
//---------------------------------------------------------------
	function Animal2(){    
	    this.name = "Animal";    
	    this.showName = function(){    
//	        console.log(this.name);    
	    }    
	}    
	  
	function Cat2(){    
	    this.name = "Cat";    
	}    
	   
	var a = new Animal2();    
	var c = new Cat2();    
	    
//  console.log(c.name);//c已执行
	a.showName.call(c,",");  //Cat 函数子域后执行的覆盖前面的this
//---------------------------------------------------------------
//??????????????????????????????????????????????????????????
//??????????????????????????????????????????????????????????
//??????????????????????????????????????????????????????????
//??????????????????????????????????????????????????????????
//??????????????????????????????????????????????????????????
	function Class10(){  
	    this.showSub = function(a,b){  
	        alert(a-b);  
	    }  
	}  
	  
	function Class11(){  
	    this.showAdd = function(a,b){  
	        alert(a+b);  
	    }  
	}  
	  
	function Class2(){  
	    Class10.call(this);  
	    Class11.call(this);  
	}  
	
	Class2(2,3);
	
//---------------------------------------------------------------
//	.apply()
	var test = function(){
		console.log(this===window)}
	test.apply(null);//true

	var arr1=new Array("1","2","3");  
	var arr2=new Array("4","5","6");  
	Array.prototype.push.apply(arr1,arr2);  
	console.log(arr1);//["1", "2", "3", "4", "5", "6"]


</script>
</body>
</html>

